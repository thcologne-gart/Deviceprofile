within mtpPackage;

model Heizkreis_TypA_final
  //--------------------
  //media
  //--------------------
  replaceable package Medium1 = AixLib.Media.Water "Water";
  replaceable package Medium2 = AixLib.Media.Water "Water";
  package Medium = AixLib.Media.Water;
  //--------------------
  //parameters
  //--------------------
  //general parameters
  parameter String pipeModel = "SimplePipe" annotation(
    choices(choice = "SimplePipe", choice = "PlugFlowPipe"),
    Dialog(group = "Parameters"));
  parameter Modelica.Units.SI.Length length "Pipe length of all pipes (can be overwritten in each pipe)" annotation(
    Dialog(group = "Pipes"));
  parameter AixLib.DataBase.Pipes.PipeBaseDataDefinition parameterPipe = AixLib.DataBase.Pipes.Copper.Copper_6x1() "Pipe type and diameter (can be overwritten in each pipe)" annotation(
    choicesAllMatching = true,
    Dialog(group = "Pipes"));
  parameter AixLib.DataBase.Pipes.InsulationBaseDataDefinition parameterIso = AixLib.DataBase.Pipes.Insulation.Iso50pc() "Insulation Type (can be overwritten in each pipe)" annotation(
    choicesAllMatching = true,
    Dialog(group = "Pipes"));
  parameter Real Kv "Kv value of valve (can be overwritten in the valve)" annotation(
    Dialog(group = "Actuators"));
  parameter Modelica.Units.SI.CoefficientOfHeatTransfer hCon = 4 "Convection heat transfer coeffient for all pipes" annotation(
    Dialog(tab = "Advanced"));
  // Assumptions
  parameter Boolean allowFlowReversal = true "= true to allow flow reversal, false restricts to design direction (port_a -> port_b)" annotation(
    Dialog(tab = "Assumptions"),
    Evaluate = true);
  parameter Boolean allowFlowReversal1 = true "= false to simplify equations, assuming, but not enforcing, no flow reversal for medium 1" annotation(
    Dialog(tab = "Assumptions"),
    Evaluate = true);
  parameter Boolean allowFlowReversal2 = true "= false to simplify equations, assuming, but not enforcing, no flow reversal for medium 2" annotation(
    Dialog(tab = "Assumptions"),
    Evaluate = true);
  // Dynamics
  parameter Modelica.Fluid.Types.Dynamics energyDynamics = Modelica.Fluid.Types.Dynamics.DynamicFreeInitial "Type of energy balance: dynamic (3 initialization options) or steady state" annotation(
    Evaluate = true,
    Dialog(tab = "Dynamics", group = "Equations"));
  parameter Modelica.Fluid.Types.Dynamics massDynamics = Modelica.Fluid.Types.Dynamics.DynamicFreeInitial "Type of mass balance: dynamic (3 initialization options) or steady state" annotation(
    Evaluate = true,
    Dialog(tab = "Dynamics", group = "Equations"));
  parameter Modelica.Units.SI.MassFlowRate m_flow_nominal(min = 1) "Nominal mass flow rate" annotation(
    Dialog(group = "Nominal condition"));
  // Initialization
  parameter Modelica.Units.SI.Temperature T_start = 303.15 "Initialization temperature" annotation(
    Dialog(tab = "Initialization"));
  // Advanced
  parameter Modelica.Units.SI.Time tau = 15 "Time Constant for PT1 behavior of temperature sensors" annotation(
    Dialog(tab = "Advanced"));
  parameter Modelica.Units.SI.Temperature T_amb = 298.15 "Ambient temperature for heat loss" annotation(
    Dialog(tab = "Advanced"));
  parameter Modelica.Units.SI.Time tauHeaTra = parameterPipe.d_i*parameterPipe.d_i/4*1000*4180*(log(parameterPipe.d_i/parameterPipe.d_o)/2/parameterPipe.lambda + log(parameterPipe.d_o/parameterPipe.d_o*(1 + parameterIso.factor))/2/parameterIso.lambda + 1/hCon/parameterPipe.d_o*(1 + parameterIso.factor)) "Time constant for heat transfer of temperature sensors to ambient" annotation(
    Dialog(tab = "Advanced"));
  parameter Modelica.Units.SI.Volume vol = 0.0005 "Mixing Volume" annotation(
    Dialog(tab = "Advanced"));
  //--------------------
  //blocks for ports
  //--------------------
  Modelica.Fluid.Interfaces.FluidPort_a port_a1(redeclare final package Medium = Medium1, m_flow(min = if allowFlowReversal1 then -Modelica.Constants.inf else 0.01), h_outflow(start = Medium1.h_default, nominal = Medium1.h_default)) annotation(
    Placement(visible = true, transformation(origin = {-200, 100}, extent = {{-10, -10}, {10, 10}}, rotation = 0), iconTransformation(origin = {-200, 100}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));
  Modelica.Fluid.Interfaces.FluidPort_a port_a2(redeclare final package Medium = Medium2, m_flow(min = if allowFlowReversal2 then -Modelica.Constants.inf else 0.01), h_outflow(start = Medium2.h_default, nominal = Medium2.h_default)) annotation(
    Placement(visible = true, transformation(origin = {200, -100}, extent = {{-10, -10}, {10, 10}}, rotation = 0), iconTransformation(origin = {200, -102}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));
  Modelica.Fluid.Interfaces.FluidPort_b port_b1(redeclare final package Medium = Medium1, m_flow(max = if allowFlowReversal1 then +Modelica.Constants.inf else 0.01), h_outflow(start = Medium1.h_default, nominal = Medium1.h_default)) annotation(
    Placement(visible = true, transformation(origin = {200, 100}, extent = {{-10, -10}, {10, 10}}, rotation = 0), iconTransformation(origin = {200, 100}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));
  Modelica.Fluid.Interfaces.FluidPort_b port_b2(redeclare final package Medium = Medium2, m_flow(max = if allowFlowReversal2 then +Modelica.Constants.inf else 0.01), h_outflow(start = Medium2.h_default, nominal = Medium2.h_default)) annotation(
    Placement(visible = true, transformation(origin = {-200, -100}, extent = {{-10, -10}, {10, 10}}, rotation = 0), iconTransformation(origin = {-200, -100}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));
  //--------------------
  //blocks for sensors
  //--------------------
  AixLib.Fluid.Sensors.TemperatureTwoPort senT_a1(redeclare package Medium = Medium, TAmb = T_amb, T_start = T_start, allowFlowReversal = allowFlowReversal, m_flow_nominal = m_flow_nominal, tau = 0.01, tauHeaTra = tauHeaTra, transferHeat = true) annotation(
    Placement(visible = true, transformation(origin = {-150, 100}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));
  AixLib.Fluid.Sensors.TemperatureTwoPort senT_b1(final m_flow_nominal = m_flow_nominal, tau = 0.01, T_start = T_start, redeclare package Medium = Medium, transferHeat = true, final TAmb = T_amb, final allowFlowReversal = allowFlowReversal, tauHeaTra = tauHeaTra) annotation(
    Placement(visible = true, transformation(origin = {150, 100}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));
  AixLib.Fluid.Sensors.TemperatureTwoPort senT_a2(redeclare package Medium = Medium, tau = 0.01, transferHeat = true, final TAmb = T_amb, final m_flow_nominal = m_flow_nominal, T_start = T_start, final allowFlowReversal = allowFlowReversal, tauHeaTra = tauHeaTra) annotation(
    Placement(visible = true, transformation(origin = {150, -100}, extent = {{10, -10}, {-10, 10}}, rotation = 0)));
  AixLib.Fluid.Sensors.TemperatureTwoPort senT_b2(tau = 0.01, T_start = T_start, redeclare package Medium = Medium, transferHeat = true, final TAmb = T_amb, final m_flow_nominal = m_flow_nominal, final allowFlowReversal = allowFlowReversal, tauHeaTra = tauHeaTra) annotation(
    Placement(visible = true, transformation(origin = {-150, -100}, extent = {{10, -10}, {-10, 10}}, rotation = 0)));
  //-----blocks boundary-----
  AixLib.Fluid.Sources.Boundary_pT bouIn(redeclare package Medium = Medium, T = 283, nPorts = 1) annotation(
    Placement(visible = true, transformation(origin = {-318, 100}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));
  AixLib.Fluid.Sources.Boundary_pT bouOut(redeclare package Medium = Medium, nPorts = 1) annotation(
    Placement(visible = true, transformation(origin = {-320, -100}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));
  //-----block consumer-----
  AixLib.Systems.HydraulicModules.SimpleConsumer simpleConsumer(redeclare package Medium = Medium, functionality = "T_fixed") annotation(
    Placement(visible = true, transformation(origin = {250, 0}, extent = {{-10, -10}, {10, 10}}, rotation = -90)));
 AixLib.Fluid.Movers.PumpsPolynomialBased.BaseClasses.PumpBus pumpBus annotation(
    Placement(visible = true, transformation(origin = {-70, 110}, extent = {{-10, 30}, {10, 50}}, rotation = 0), iconTransformation(origin = {0, 0}, extent = {{-10, 30}, {10, 50}}, rotation = 0)));
 Modelica.Blocks.Sources.BooleanPulse PumpOn(period = 600, width = 500/600*100) annotation(
    Placement(visible = true, transformation(origin = {-70, 110}, extent = {{-70, 30}, {-50, 50}}, rotation = 0)));
 Modelica.Blocks.Sources.Ramp rampPumpSpeed(duration(displayUnit = "s") = 100, height = pump.pumpParam.nMax - pump.pumpParam.nMin + 200, offset = pump.pumpParam.nMin - 100, startTime(displayUnit = "s") = 100) annotation(
    Placement(visible = true, transformation(origin = {-70, 110}, extent = {{46, 30}, {26, 50}}, rotation = 0)));
 AixLib.Fluid.Movers.PumpsPolynomialBased.PumpSpeedControlled pump(
    m_flow_nominal=m_flow_nominal,
    pumpParam=AixLib.DataBase.Pumps.PumpPolynomialBased.Pump_DN25_H1_6_V4(),
    calculatePower=true,
    calculateEfficiency=true,
    redeclare function efficiencyCharacteristic =
        AixLib.Fluid.Movers.PumpsPolynomialBased.BaseClasses.efficiencyCharacteristic.Wilo_Formula_efficiency,
    redeclare package Medium = Medium) annotation(
    Placement(visible = true, transformation(origin = {-70, 100}, extent = {{-10, -10}, {10, 10}}, rotation = 0))); equation
  connect(bouIn.ports[1], port_a1) annotation(
    Line(points = {{-308, 100}, {-200, 100}}, color = {0, 127, 255}));
  connect(bouOut.ports[1], port_b2) annotation(
    Line(points = {{-310, -100}, {-200, -100}}, color = {0, 127, 255}));
  connect(senT_a1.port_a, port_a1) annotation(
    Line(points = {{-160, 100}, {-200, 100}}, color = {0, 127, 255}));
  connect(senT_b2.port_b, port_b2) annotation(
    Line(points = {{-160, -100}, {-200, -100}}, color = {0, 127, 255}));
  connect(senT_a2.port_b, senT_b2.port_a) annotation(
    Line(points = {{140, -100}, {-140, -100}}, color = {0, 127, 255}));
  connect(port_a2, senT_a2.port_a) annotation(
    Line(points = {{200, -100}, {160, -100}}));
  connect(senT_b1.port_b, port_b1) annotation(
    Line(points = {{160, 100}, {200, 100}}));
  connect(simpleConsumer.port_a, port_b1) annotation(
    Line(points = {{250, 10}, {250, 100}, {200, 100}}, color = {0, 127, 255}));
  connect(simpleConsumer.port_b, port_a2) annotation(
    Line(points = {{250, -10}, {250, -100}, {200, -100}}, color = {0, 127, 255}));
  connect(rampPumpSpeed.y, pumpBus.rpmSet) annotation(
    Line(points = {{-45, 150}, {-69.95, 150}, {-69.95, 150.05}}, color = {0, 0, 127}));
  connect(PumpOn.y, pumpBus.onSet) annotation(
    Line(points = {{-119, 150}, {-98, 150}, {-98, 150}, {-84, 150}, {-84, 150.05}, {-69.95, 150.05}}, color = {255, 0, 255}));
 connect(senT_a1.port_b, pump.port_a) annotation(
    Line(points = {{-140, 100}, {-80, 100}}, color = {0, 127, 255}));
 connect(pump.port_b, senT_b1.port_a) annotation(
    Line(points = {{-60, 100}, {140, 100}}, color = {0, 127, 255}));
 connect(pump.pumpBus, pumpBus) annotation(
    Line(points = {{-70, 110}, {-70, 150}}, color = {255, 204, 51}, thickness = 0.5));
  annotation(
    Diagram(coordinateSystem(extent = {{-200, -200}, {200, 200}})),
    Icon(coordinateSystem(extent = {{-200, -200}, {200, 200}})),
    experiment(StartTime = 0, StopTime = 1000, Tolerance = 1e-06, Interval = 0.002),
    __OpenModelica_commandLineOptions = "--matchingAlgorithm=PFPlusExt --indexReductionMethod=dynamicStateSelection -d=initialization,NLSanalyticJacobian",
    __OpenModelica_simulationFlags(lv = "LOG_STATS", s = "dassl"));
end Heizkreis_TypA_final;
